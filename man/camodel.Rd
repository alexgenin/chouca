% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parsing.R
\name{camodel}
\alias{camodel}
\alias{transition}
\title{Definition of a probabilistic cellular automaton}
\usage{
camodel(
  ...,
  neighbors,
  wrap,
  continuous = FALSE,
  parms = list(),
  all_states = NULL,
  check_model = "quick",
  verbose = FALSE,
  epsilon = sqrt(.Machine[["double.eps"]]),
  fixed_neighborhood = FALSE
)

transition(from, to, prob)
}
\arguments{
\item{...}{a number of transition descriptions, as built by the
\code{\link{transition}} function (see Details and Examples)}

\item{neighbors}{The number of neighbors to use in the cellular automaton (4 for 4-way 
or von-Neumann neghborhood, or 8 for an 8-way or Moore neighborhood)}

\item{wrap}{If \code{TRUE}, then the 2D grid on which the model is run wraps around 
at the edges (the top/leftmost cells will be considered neighbors of the 
bottom/rightmost cells)}

\item{continuous}{If \code{TRUE}, the model definition should be treated as a 
continuous stochastic cellular automaton}

\item{parms}{a named list of parameters, which should be all numeric, single values}

\item{all_states}{the complete list of states (a character vector). If unspecified,
it will be guessed from the transition rules, but it is a good idea pass it here 
to make sure the model definition is correct.}

\item{check_model}{A check of the model definition is done to make sure there 
are no issues with it (e.g. probabilities outside the [1,0] interval, or an 
unsupported model definition). A quick check that should catch most problems is
performed if check_model is "quick", an extensive check that tests all 
neighborhood configurations is done with "full", and no check is performed with 
"none".}

\item{verbose}{whether information should be printed when parsing the model
definition.}

\item{epsilon}{A small value under which coefficient values are considered to be 
equal to zero}

\item{fixed_neighborhood}{When not using wrapping around the edges (\code{wrap = TRUE},
the number of neighbors per cell is variable, which can slow down the simulation. 
Set this option to \code{TRUE} to consider that the number of neighbors is always 
four or eight, regardless of the position of the cell in the landscape, at the cost 
of approximate dynamics on the edge of the landscape.}

\item{from}{The state from which the transition is defined}

\item{to}{The state to which the transition is defined}

\item{prob}{a one-sided formula describing the probability of transition between the two 
states (see Details section for more information).}
}
\description{
High-level definition of a probabilistic cellular automaton
}
\details{
This function allows defining a stochastic cellular automaton model by its set of
transition rules. These are defined by a set of calls to the \code{transition()}
function. Each of these calls defines the two states of the transition, and the
probability (as a one-sided formula involving constants and special values p, q, 
etc.). 

\code{transition()} calls takes three arguments: the state from which the transition 
is defined, the state to which the transition goes, and a transition probability, 
defined as a one-sided formula. This formula can include numerical constants, 
parameters defined in the named list \code{parms}, and any combination of p['a'] 
and q['b'], which respectively represent the proportion of cells in a landscape in 
state 'a', and the proportion of neighbors of a given cell in state 'b' ('a', and 
'b' being, of course, any of the possible states defined in the model). See 
section Examples for examples of model implementations. 

It is important to remember when using this function that \code{chouca} only 
supports models where the probabilities follow the following functional form: 

P = \deqn{\beta_0 + \sum_{k=1}^S f(q_k) + \sum{k=1}^S \beta^p_k p_k + \beta^{pq}_1 p^2q^2 \dots \beta^{pq}_I p^5q^5 + \beta^{pp}_J p^2p^2 \dots \beta^{pp}_J p^5p^5 + + \beta^{qq}_K q^2q^2 \dots \beta^{qq}_K q^5q^5}

where p_{k} and q_{k} are the proportions of cells in state k in the landscape, and 
in the cell neighborhood, respectively, and the various \eqn{\beta} coefficient 
are estimated by \code{chouca} internally. When \code{check_model} is "quick" or 
"full", a check is performed to make sure the functional form above is able to 
accurately represent probabilities of transitions in the model, with "full" enabling 
more extensive tesing, and "none" removing it entirely.  

When using chouca, very small coefficients in the formula above may be rounded down 
to zero. This may be an issue if your transition probabilities are very low: in 
this case, consider reducing \code{epsilon} to a smaller value. 

To run a model once it is defined, the function \code{\link{run_camodel}} can be 
used, or \code{\link{run_meanfield}} for a mean-field approximation. An initial 
landscape for a simulation can be created using \code{\link{generate_initmat}}.
}
\section{Functions}{
\itemize{
\item \code{transition()}: 

}}
\examples{

# Redefine Kubo's 1996 forest gap model 
kubo <- camodel( 
  transition(from = "TREE", 
             to   = "EMPTY", 
             prob = ~ d + delta * q["EMPTY"] ), 
  transition(from = "EMPTY", 
             to   = "TREE", 
             prob = ~ alpha), 
  parms = list(d = 0.125, 
               delta = 0.5, 
               alpha = 0.2), 
  all_states = c("EMPTY", "TREE"), 
  neighbors = 4, 
  wrap = TRUE, 
  continuous = FALSE
)

# A fun plant model 
mod <- camodel(
  transition("plant", "empty", ~ death * ( 1 - (2*q["plant"]-1)^2) ), 
  transition("empty", "plant", ~ q["plant"]^2 ), 
  all_states = c("empty", "plant"), 
  wrap = TRUE, 
  neighbors = 4, 
  continuous = FALSE, 
  parms = list(death = 0.2496)
)

# Conway's Game of Life 
mod <- camodel( 
  transition("LIVE", "DEAD", ~ q["LIVE"] < (2/8) | q["LIVE"] > (3/8)), 
  transition("DEAD", "LIVE", ~ q["LIVE"] == (3/8)), 
  wrap = TRUE, 
  neighbors = 8, 
  continuous = FALSE, 
  all_states = c("DEAD", "LIVE")
)

# A spiral-generating rock-paper-scissor model
mod <- camodel(
  transition(from = "r", to = "p", ~ prob * ( q["p"] > (1/8)*2) ), 
  transition(from = "p", to = "c", ~ prob * ( q["c"] > (1/8)*2) ), 
  transition(from = "c", to = "r", ~ prob * ( q["r"] > (1/8)*2) ), 
  parms = list(prob = 1), 
  wrap = TRUE, 
  continuous = FALSE, 
  neighbors = 8
)

}
\seealso{
run_camodel, generate_initmat, run_meanfield
}
