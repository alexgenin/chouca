<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Alexandre Génin a.a.h.genin@uu.nl" />


<title>The complete guide to chouca</title>

<script src="guide_files/header-attrs-2.14/header-attrs.js"></script>
<script src="guide_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="guide_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="guide_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="guide_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="guide_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="guide_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="guide_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="guide_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="guide_files/navigation-1.1/tabsets.js"></script>
<script src="guide_files/navigation-1.1/codefolding.js"></script>
<link href="guide_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="guide_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-show-all-code" href="#">Show All Code</a></li>
<li><a id="rmd-hide-all-code" href="#">Hide All Code</a></li>
</ul>
</div>



<h1 class="title toc-ignore">The complete guide to
<code>chouca</code></h1>
<h4 class="author">Alexandre Génin <a href="mailto:a.a.h.genin@uu.nl"
class="email">a.a.h.genin@uu.nl</a></h4>

</div>


<style type="text/css">
<!-- Make sure videos are centered -->
video { 
  margin-left:auto; 
  margin-right:auto; 
  display:block; 
}

</style>
<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p><code>chouca</code> is engine in R for <a
href="https://en.wikipedia.org/wiki/Stochastic_cellular_automaton">stochastic
cellular automata</a>, which are models that describes the temporal
dynamics of a 2D landscape made of cells. Each cell can be in one of a
finite number of states, and switch states over time with probabilities
that depend on their neighborhood.</p>
<p>A picture being worth a thousand words, the output of a stochastic
cellular automaton looks like the following animation in practice:</p>
<video width="288" controls loop>
<source src="guide_files/figure-html/gifcreate.webm" />
</video>
<p>Stochastic cellular automata are widely used to describe the dynamics
of landscapes, for example, that of forests or coral reefs over space.
Yet, implementations are often ad-hoc, carried out by the authors
themselves, which is prone to bugs and often leads to quite slow
implementations. <code>chouca</code> tries to avoid this by providing a
base onto which such models can be built. The goal is for the user to
declare the probabilities of state transitions of the model, then
<code>chouca</code> handles the rest.</p>
<p>While <code>chouca</code> is built mainly for stochastic cellular
automata, it can also handle non-stochastic cellular automata, such as
the game of life or the <a
href="https://www.youtube.com/watch?v=TvZI6Xc0J1Y">rock-paper-scissor
automaton</a>. If you are specifically interested in deterministic
cellular automata though, there are probably better alternatives to run
your model. Chouca supports a wide selection of models, while preserving
decent performance. This is done by writing most of the code in C++, and
being able to emit and compile C++ code on the fly for a specific model
at run time. This enables compiler optimizations that would be
impossible with pre-compiled code, and often improves simulation speed
by one or two orders of magnitude. Chouca can also use a
memoisation-based strategy to run simulations, in which probabilities
are not recomputed for each cell at each iteration, providing another
boost in perfmance. For supported models, chouca may probably be 3 to 4
orders of magnitude faster than the common implementations.</p>
<div id="your-first-model-in-chouca" class="section level2">
<h2>Your first model in <code>chouca</code></h2>
<p>Let’s implement a small forest gap model (Kubo et al. 1996). In such
model, cells can be either ‘empty’, or filled with a tree, what we call
here the ‘forest’ state. Trees produce seeds that can fly over the whole
landscape and land haphazardly in any cell. Thus, the probability of an
empty cell to switch to the forested state is proportional to <span
class="math inline">\(p_+\)</span>, the proportion of cells with trees
in the landscape. If we represent the empty state as <span
class="math inline">\(0\)</span> and the forest state as <span
class="math inline">\(+\)</span>, this probability of transition is
thus:</p>
<p><span class="math display">\[P(0 \rightarrow +) = \alpha
p_{forest}\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is the rate at
which seeds are produced by each tree.</p>
<p>Trees naturally die over time, and because wind bursts are stronger
in empty areas, trees have a higher probability of dying when they have
empty neighboring cells:</p>
<p><span class="math display">\[P(+ \rightarrow 0) = \delta_0 + \delta
q_{empty}\]</span></p>
<p>Here, <span class="math inline">\(q_{empty}\)</span> denotes the
proportion of cells around the focal cell that are empty, i.e. in the
“empty” state. <span class="math inline">\(q_{empty}\)</span> is equal
to one when a cell has all of its neighbors in the empty state, and zero
when none of the neighbors is in this state.</p>
<p>This model has three parameters, <span
class="math inline">\(\alpha\)</span>, <span
class="math inline">\(\delta_0\)</span> and <span
class="math inline">\(\delta\)</span>, and can be defined in
<code>chouca</code> using the following syntax:</p>
<pre class="r"><code>kubo_model &lt;- camodel(transition(from = &quot;empty&quot;,  to = &quot;forest&quot;, 
                                 ~ alpha * p[&quot;forest&quot;]), 
                      transition(from = &quot;forest&quot;, to = &quot;empty&quot;,  
                                 ~ delta0 + delta * q[&quot;empty&quot;]), 
                      parms = list(alpha = 0.6, delta0 = 0.05, delta = 0.4), 
                      wrap = TRUE, 
                      neighbors = 8)</code></pre>
<p>We first declare the two transitions, i.e. the states between which
they occur, and an expression describing how to compute the probability.
In that expression, <code>p</code> refers to the proportions of cells of
the landscape in each state, and <code>q</code> refers to the the
proportion of neighbors in each state. <code>q["forest"]</code> for
example represents the proportion of neighbors in the
<code>forest</code> state, which is a number between 0 and 1.</p>
<p>We then set the argument <code>parms</code> to a list containing the
numerical values of the model parameters. We use the argument
<code>wrap = TRUE</code> to state that the model will be run on a space
in which the edges “wrap around”, and the first column/top row of the
landscape is neighboring the rightmost/bottom column (a toric space). We
use the argument <code>neighbors = 8</code> to state that we want to
consider all 8 neighbors of a cell, i.e. including those that are
diagonal. This type of neighborhood is referred to as <a
href="https://en.wikipedia.org/wiki/Moore_neighborhood">Moore</a>
neighborhood, the other supported type being a 4-way (Von-Neumann)
neighborhood.</p>
<p>A summary of the model can be printed on the R command line, that
recalls the model definition and options.</p>
<pre class="r"><code>kubo_model</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: empty forest 
##  
## Transition: empty -&gt; forest 
##   ~   alpha * p[&quot;forest&quot;] 
## Transition: forest -&gt; empty 
##   ~   delta0 + delta * q[&quot;empty&quot;] 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Continuous: FALSE 
## Max error: 1.110223e-16 (OK) 
## Max rel error: 2.816902e-16 (OK)</code></pre>
<p>The next step is to define the initial landscape from which we want
to start the simulation. We can do so using the function
<code>generate_initmat</code>:</p>
<pre class="r"><code>init_mat &lt;- generate_initmat(kubo_model, pvec = c(empty = 0.5, forest = 0.5), 
                             nr = 128, nc = 256)</code></pre>
<p>Here we initalize the covers to half forest and half empty space
using the argument <code>pvec</code>, and use a landscape of 128 rows by
256 columns. We can now run the simulation:</p>
<pre class="r"><code>out &lt;- run_camodel(kubo_model, init_mat, times = seq(0, 100))</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.504 forest:0.496 
## iter =  10 ( 10 %) empty:0.296 forest:0.704 [129.87 iter/s]
## iter =  20 ( 20 %) empty:0.232 forest:0.768 [135.14 iter/s]
## iter =  30 ( 30 %) empty:0.229 forest:0.771 [135.14 iter/s]
## iter =  40 ( 40 %) empty:0.227 forest:0.773 [135.14 iter/s]
## iter =  50 ( 50 %) empty:0.227 forest:0.773 [135.14 iter/s]
## iter =  60 ( 59 %) empty:0.229 forest:0.771 [131.58 iter/s]
## iter =  70 ( 69 %) empty:0.231 forest:0.769 [135.14 iter/s]
## iter =  80 ( 79 %) empty:0.226 forest:0.774 [136.99 iter/s]
## iter =  90 ( 89 %) empty:0.224 forest:0.776 [135.14 iter/s]
## iter = 100 ( 99 %) empty:0.224 forest:0.776 [135.14 iter/s]</code></pre>
<p>We can then display the results, either in the R console using
<code>summary()</code>, or as a plot using the generic function
<code>plot()</code>, which displays the global covers of each state
through time, or <code>image()</code>, which displays the landscape:</p>
<pre class="r"><code>summary(out)</code></pre>
<pre><code>## Stochastic Cellular Automaton simulation
## 
## Times: 0 to 100
## Landscape size: 128x256
## Global covers:
##          t     empty    forest
##  [96,]  95 0.2321472 0.7678528
##  [97,]  96 0.2332458 0.7667542
##  [98,]  97 0.2265930 0.7734070
##  [99,]  98 0.2258911 0.7741089
## [100,]  99 0.2248230 0.7751770
## [101,] 100 0.2243042 0.7756958
## Landscapes saved: 2
## 
## The following methods are available: 
##    image plot 
## 
## Extract simulation results using one of:
##   out[[&quot;output&quot;]][[&quot;covers&quot;]]
##   out[[&quot;output&quot;]][[&quot;snapshots&quot;]]</code></pre>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(out)
title(&quot;Global covers over time&quot;)
image(out)</code></pre>
<p><img src="guide_files/figure-html/display_plot-1.png" width="1152" style="display: block; margin: auto;" /></p>
</div>
<div id="supported-models" class="section level2">
<h2>Supported models</h2>
<p><code>chouca</code> works only with models that use either a 4x4 or
8x8 neighborhood (von Neumann or Moore neighborhood, respectively), and
in which the effects are isotropic, i.e. all neighbors have a similar
effect regardless of whether they are above, or below a given cell.
Cellular automata that involve a preferencial direction cannot be
implemented in <code>chouca</code>, for example with water running
downslope in a landscape (Mayor et al. 2013).</p>
<p>The probabilities of transition can have any form, but respecting
those two principles will work better:</p>
<ul>
<li><p>To be accurately computed, transition probabilities must be a
linear polynomial of the products of the local or global proportion of
cells in a given state. For example, a transition probability defined
between states <span class="math inline">\(i\)</span> and <span
class="math inline">\(j\)</span> as <span class="math inline">\(P(i
\rightarrow j) = 0.1 + p_i + p_j q_i\)</span> works perfectly, but
something involving non-linear functions such as <span
class="math inline">\(P(0 \rightarrow +) = 0.1 + sin(p_i)\)</span> may
not be correctly handled (see below for the consequences).</p></li>
<li><p>There is some tolerance is discontinuities in the transition
rules. Rules such as “if one neighbor is in state <span
class="math inline">\(i\)</span>, then the probability of transition is
increased” are OK. However, such rule involving multiple types of
neighbors are not, e.g. “if one neighbor is in state <span
class="math inline">\(i\)</span> <em>and</em> another one in state <span
class="math inline">\(j\)</span>, then…”. This type of discontinuity is
hard to accomodate.</p></li>
</ul>
<p>Overall, the assumed functional form of transitions probabilities
must be the following:</p>
<p><span class="math display">\[
P( a \rightarrow b ) = \beta_0 \\
  + \sum_{s \in S} f_s(q_s) \\
  + \alpha_1 p_1 ... \alpha_n p_S \\
  + \beta_1  p_1 p_2 + p_1 p_2^2 + p_1^2 p_2 ...  \beta_n p_S^k p_S^k \\
  + \gamma_1 q_1 q_2 + q_1 q_2^2 + q_1^2 q_2 ... \gamma_n q_{S-1}^k
q_S^k \\
  + \delta_1 p_1 q_1 + p_1 q_1^2 + p_1^2 q_1 ... \delta_n p_S^k q_S^k
\]</span></p>
<p>where <span class="math inline">\(S\)</span> represents the set of
states of the cellular automaton, <span
class="math inline">\(f_s\)</span> can be any function of <span
class="math inline">\(q_s\)</span>. All the <span
class="math inline">\((\alpha_i)\)</span>, <span
class="math inline">\((\beta_i)\)</span>, <span
class="math inline">\((\gamma_i)\)</span> and <span
class="math inline">\((\delta_i)\)</span> are constants (model
parameters). Many models can be represented using this functional form -
however, this may not always be the case, especially as soon as
non-linear functions are involved (exp, sin, etc.), or functions with
discontinuities. This functional form can be daunting, but
<code>chouca</code> will warn you if the transition probabilities cannot
be accurately modelled, so the best way is to write your model and see
if it is supported.</p>
<p>For all models, <code>chouca</code> reports an estimation of the
error on the probabilities of transition, and whether those can be above
one or below zero. For example, the above mussel bed model can be
perfectly represented by <code>chouca</code>, so the reported error is
zero:</p>
<pre class="r"><code>print(kubo_model)</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: empty forest 
##  
## Transition: empty -&gt; forest 
##   ~   alpha * p[&quot;forest&quot;] 
## Transition: forest -&gt; empty 
##   ~   delta0 + delta * q[&quot;empty&quot;] 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Continuous: FALSE 
## Max error: 1.110223e-16 (OK) 
## Max rel error: 2.816902e-16 (OK)</code></pre>
<p>The following model, which includes an exponential function of the
neighborhood, has a non-zero error, because this exponential function
cannot be perfectly approximated by a polynomial:</p>
<pre class="r"><code>mod &lt;- camodel(transition(from = &quot;dead&quot;, to = &quot;live&quot;, 
                          ~ 0.1 + exp(0.2 * q[&quot;dead&quot;] + p[&quot;dead&quot;])), 
               transition(from = &quot;live&quot;, to = &quot;dead&quot;, 
                          ~ 0.1), 
               wrap = TRUE, 
               neighbors = 8)
print(mod)</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: dead live 
##  
## Transition: dead -&gt; live 
##   ~   0.1 + exp(0.2 * q[&quot;dead&quot;] + p[&quot;dead&quot;]) 
## Transition: live -&gt; dead 
##   ~   0.1 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Continuous: FALSE 
## Max error: 0.0001398803 (OK) 
## Max rel error: 9.181989e-05 (OK)</code></pre>
<p>The reported maximum absolute error on the probability of transitions
is 0.00014, which is very small. The relative maximum error, in other
words the error in percentage of the exact probability, is also very
small (9.2e-05). Because both of this probabilities are very small, you
are probably safe to run this model in chouca and obtain correct
results, despite the fact that it does not follow the ideal form.</p>
<p>The following model gives more trouble:</p>
<pre class="r"><code>mod &lt;- camodel(transition(from = &quot;dead&quot;, to = &quot;live&quot;, 
                          ~ 0.1 + sin(pi * q[&quot;dead&quot;] * p[&quot;dead&quot;] )), 
               transition(from = &quot;live&quot;, to = &quot;dead&quot;, 
                          ~ 0.1), 
               wrap = TRUE, 
               neighbors = 8)</code></pre>
<pre><code>## Warning: Residual error in computed probabilities
##   max error: 0.246
##   max rel error: 1.27
## Problematic probability expression: 
## Transition from dead to live
##   ~ 0.1 + sin(pi * q[&quot;dead&quot;] * p[&quot;dead&quot;])</code></pre>
<pre class="r"><code>print(mod)</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: dead live 
##  
## Transition: dead -&gt; live 
##   ~   0.1 + sin(pi * q[&quot;dead&quot;] * p[&quot;dead&quot;]) 
## Transition: live -&gt; dead 
##   ~   0.1 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Continuous: FALSE 
## Max error: 0.2463987 (WARNING) 
## Max rel error: 1.270006 (WARNING)</code></pre>
<p>Here, both the absolute and relative errors on the computed
probabilities are non-negligible (0.25 and 1.3). A warning is produced,
and the problematic transition is pointed out. You should probably
revise this model if you want to make it work with <code>chouca</code>.
A possible approach is to approximate the function by a taylor expansion
of <span class="math inline">\(sin\)</span>, for example using the
expansion in zero: <span class="math inline">\(sin(x) \approx x -
\frac{x^3}{3!} + \frac{x^5}{5!}\)</span>.</p>
<pre class="r"><code>sin_approx &lt;- function(x) { 
  x - x^3/factorial(3) + x^5/factorial(5) 
}

mod &lt;- camodel(transition(from = &quot;dead&quot;, to = &quot;live&quot;, 
                          ~ 0.1 + sin_approx(pi * q[&quot;dead&quot;] * p[&quot;dead&quot;]) ), 
               transition(from = &quot;live&quot;, to = &quot;dead&quot;, 
                          ~ 0.1), 
               wrap = TRUE, 
               neighbors = 8)
print(mod) # negligible error this time, as we use an approximation of sin()</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: dead live 
##  
## Transition: dead -&gt; live 
##   ~   0.1 + sin_approx(pi * q[&quot;dead&quot;] * p[&quot;dead&quot;]) 
## Transition: live -&gt; dead 
##   ~   0.1 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Continuous: FALSE 
## Max error: 1.559383e-11 (OK) 
## Max rel error: 9.762318e-11 (OK)</code></pre>
</div>
</div>
<div id="performance" class="section level1">
<h1>Performance</h1>
<p>One of the main appeal of <code>chouca</code> is its performance:
which is affected by various factors. The main one is the model
complexity. Using a model with transition probabilities that are
complicated products of global or neighbor covers, or that do not fit
well the functional form expected will lead to poor performance. When
possible, try to make your model follow those forms. However, several
approaches exist to improve simulation speed in chouca, regardless of
the model: (i) on-the-fly compilation, (ii) memoisation of transition
probabilities and (iii) multithreading.</p>
<p>On-the-fly compilation can be enabled using the “compiled” engine to
run the cellular automaton. This is done by setting the
<code>engine</code> control argument to “compiled”:</p>
<pre class="r"><code>control_args &lt;- list(engine = &quot;compiled&quot;, 
                     precompute_probas = FALSE, 
                     console_output_every = 128) 

out &lt;- run_camodel(kubo_model, 
                   initmat = init_mat, 
                   times = seq(0, 512), 
                   control = control_args)</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.504 forest:0.496 
## iter = 128 ( 25 %) empty:0.226 forest:0.774 [472.32 iter/s]
## iter = 256 ( 50 %) empty:0.226 forest:0.774 [490.42 iter/s]
## iter = 384 ( 75 %) empty:0.227 forest:0.773 [486.69 iter/s]
## iter = 512 (100 %) empty:0.232 forest:0.768 [488.55 iter/s]</code></pre>
<p>On the first run, this model will take a few extra seconds to run as
the C++ code corresponding to the model needs to be compiled. However,
the simulation itself will be much faster. Compilation only needs to be
done when the structure of the model, or the size of the landscape
changes. A simple change in parameter value will not trigger a new
compilation, except when the probabilities of transition can be
simplified, for example when a parameter goes to zero and part of the
equation can be left out.</p>
<p>Another approach to better performance lies in the precomputation of
probabilities. The classic approach to run a CA is to consider each cell
in the landscape one by one, and compute its probability of transition
to every state it could switch to. This may entail a lot of repeated
computations, as many cells will have the same neighborhood
configuration. To avoid this, we can compute the probabilities of
transition for every neighborhood configuration, and just look the
number up to know whether cells switch or not. This approach is enabled
by using the argument <code>precompute_probas</code> in the control
list:</p>
<pre class="r"><code>control_args &lt;- list(engine = &quot;compiled&quot;, 
                     precompute_probas = TRUE, 
                     console_output_every = 128) 

out &lt;- run_camodel(kubo_model, 
                   initmat = init_mat, 
                   times = seq(0, 512), 
                   control = control_args)</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.504 forest:0.496 
## iter = 128 ( 25 %) empty:0.225 forest:0.775 [3121.95 iter/s]
## iter = 256 ( 50 %) empty:0.231 forest:0.769 [3764.71 iter/s]
## iter = 384 ( 75 %) empty:0.229 forest:0.771 [3878.79 iter/s]
## iter = 512 (100 %) empty:0.229 forest:0.771 [3657.14 iter/s]</code></pre>
<p>This approach can dramatically improve the performance for models
that have a small number of states and simple transition rules. However,
it may be counter-productive for models with a larger number of states,
as the number of neighborhood configurations grows very quickly with the
number of different model states (<span
class="math inline">\(S^4\)</span> or <span
class="math inline">\(S^8\)</span> depending on the type of
neighborhood). By default, a simple heuristic is used to make a decent
choice.</p>
<p>The last approach to improve performance is to use multithreading. In
chouca, the approach is to consider the updating of cells in parallel,
instead of doing it serially. However, there is some synchronisation
work required between threads to make sure the different cores are not
writing to shared data structures. This often results in a significant
overhead, and only small performance improvements.</p>
<pre class="r"><code>control_args &lt;- list(engine = &quot;compiled&quot;, 
                     precompute_probas = TRUE, 
                     cores = 4, 
                     console_output_every = 128) 

out &lt;- run_camodel(kubo_model, 
                   initmat = init_mat, 
                   times = seq(0, 512), 
                   control = control_args)</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.504 forest:0.496 
## iter = 128 ( 25 %) empty:0.221 forest:0.779 [3555.56 iter/s]
## iter = 256 ( 50 %) empty:0.229 forest:0.771 [6400.00 iter/s]
## iter = 384 ( 75 %) empty:0.228 forest:0.772 [5565.22 iter/s]
## iter = 512 (100 %) empty:0.228 forest:0.772 [7111.11 iter/s]</code></pre>
<p>Future improvements of the package may improve this situation. In the
meantime, if you happen to be running several simulations at the same
time (which is often the case), you are probably better off
parallelizing at a higher level.</p>
<p>Finally, because the model code is compiled on the fly, you may be
able to use optimizations that are specific to your combination of
platform and compiler. The best way to do so is to edit your platform
<code>~/.R/Makevars</code> file to add the flags you want, such as
<code>CXXFLAGS=-O3 -march=native -mtune=native</code>. However, do not
expect too much as most of the time this does not bring much more
performance to the table.</p>
<p>Below is a summary of performance for the forest gap model, different
options and landscape sizes:</p>
<pre class="r"><code>sizes &lt;- 2^seq(3, 6)

benchmark &lt;- ldply(sizes, function(size) { 
  
  ctrl &lt;- list(force_compilation = TRUE, 
               console_output_every = 0)
  niters &lt;- 256
  
  ldply(c(&quot;cpp&quot;, &quot;compiled&quot;), function(engine) { 
    ldply(c(TRUE, FALSE), function(precomp) { 
      if ( precomp &amp;&amp; engine == &quot;cpp&quot; ) { 
        return(NULL)
      }
      
      ctrl[[&quot;engine&quot;]] &lt;- engine
      ctrl[[&quot;precompute_probas&quot;]] &lt;- precomp
      
      init &lt;- generate_initmat(kubo_model, c(forest = 0.5, empty = 0.5), 
                               nr = size, nc = size)
      
      run1 &lt;- system.time({ 
        run &lt;- run_camodel(kubo_model, init, seq(0, niters), 
                           control = ctrl)
      })
      
      ctrl[[&quot;force_compilation&quot;]] &lt;- FALSE
      
      run2 &lt;- system.time({ 
        run &lt;- run_camodel(kubo_model, init, seq(0, niters), 
                           control = ctrl)
      })
      
      print(
      data.frame(size = size, 
                 proba_precomp = precomp, 
                 engine = engine, 
                 run1 = run1[[&quot;elapsed&quot;]], 
                 run2 = run2[[&quot;elapsed&quot;]])
      )      
    })
  })
})


bench &lt;- gather(benchmark, &quot;run_type&quot;, &quot;run_time&quot;, c(&quot;run1&quot;, &quot;run2&quot;))
bench[ ,&quot;run_type&quot;] &lt;- c(run1 = &quot;cold&quot;, run2 = &quot;warm&quot;)[bench[ ,&quot;run_type&quot;]]
ggplot(bench, 
       aes(x = size, 
           y = run_time, 
           linetype = run_type, 
           color = paste0(engine, 
                         ifelse(proba_precomp, &quot;+precomp&quot;, &quot;&quot;)))) + 
  geom_point() + 
  geom_line() + 
  scale_color_discrete(name = &quot;Type&quot;) + 
  scale_y_continuous(trans = &quot;log2&quot;) + 
  scale_x_continuous(trans = &quot;log2&quot;) +
  scale_linetype(name = &quot;Run type&quot;) + 
  theme_minimal() + 
  labs(x = &quot;Landscape size&quot;, 
       y = &quot;Run time (s)&quot;)</code></pre>
<p><img src="guide_files/figure-html/benhmarks-1.png" width="672" style="display: block; margin: auto;" /></p>
</div>
<div id="storingdiscardingaccessing-data" class="section level1">
<h1>Storing/discarding/accessing data</h1>
<p>Various options are available to access simulation outputs. When
nothing is specified, the percentage of cells in each state will be
saved at each time step specified in the <code>times</code> vector
(argument to <code>run_camodel()</code>), and the landscape at the first
and last time step will be saved. These can be accessed simply by
acessing elements of the object returned by
<code>run_camodel()</code>.</p>
<p>Global covers are saved as a matrix whose first column is the time,
and the others the percentages for each state:</p>
<pre class="r"><code>init &lt;- generate_initmat(kubo_model, c(forest = 0.5, empty = 0.5), 
                         nr = 128)

run &lt;- run_camodel(kubo_model, init, times = seq(0, 128, by = 1))</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.498 forest:0.502 
## iter =  10 (  8 %) empty: 0.3 forest: 0.7 [256.41 iter/s]
## iter =  20 ( 16 %) empty:0.234 forest:0.766 [256.41 iter/s]
## iter =  30 ( 23 %) empty:0.226 forest:0.774 [256.41 iter/s]
## iter =  40 ( 31 %) empty:0.231 forest:0.769 [270.27 iter/s]
## iter =  50 ( 39 %) empty:0.226 forest:0.774 [263.16 iter/s]
## iter =  60 ( 47 %) empty:0.227 forest:0.773 [263.16 iter/s]
## iter =  70 ( 54 %) empty:0.23 forest:0.77 [263.16 iter/s]
## iter =  80 ( 62 %) empty:0.228 forest:0.772 [270.27 iter/s]
## iter =  90 ( 70 %) empty:0.226 forest:0.774 [270.27 iter/s]
## iter = 100 ( 78 %) empty:0.232 forest:0.768 [263.16 iter/s]
## iter = 110 ( 85 %) empty:0.234 forest:0.766 [263.16 iter/s]
## iter = 120 ( 93 %) empty:0.232 forest:0.768 [250.00 iter/s]</code></pre>
<pre class="r"><code>covers &lt;- run[[&quot;output&quot;]][[&quot;covers&quot;]]
tail(covers)</code></pre>
<pre><code>##          t     empty    forest
## [124,] 123 0.2269287 0.7730713
## [125,] 124 0.2214355 0.7785645
## [126,] 125 0.2234497 0.7765503
## [127,] 126 0.2197876 0.7802124
## [128,] 127 0.2217407 0.7782593
## [129,] 128 0.2200317 0.7799683</code></pre>
<p>The landscape are also available, using the following syntax. A nifty
function to display landscapes is available in the spatialwarnings
package, <code>display_matrix</code>:</p>
<pre class="r"><code>landscapes &lt;- run[[&quot;output&quot;]][[&quot;snapshots&quot;]]
spatialwarnings::display_matrix(landscapes)</code></pre>
<pre><code>## Warning in FUN(X[[i]], ...): The matrix has only two unique values, but it is
## not of logical type. Did you mean to use TRUE/FALSE values?

## Warning in FUN(X[[i]], ...): The matrix has only two unique values, but it is
## not of logical type. Did you mean to use TRUE/FALSE values?</code></pre>
<p><img src="guide_files/figure-html/unnamed-chunk-13-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Sometimes, we do not want to store everything at all time steps. One
option to reduce output is to specify a diferrent <code>times</code>
vector to <code>run_camodel()</code>. This will not affect the precision
of the simulation, but will simply reduce the time points at which
simulation output is saved.</p>
<pre class="r"><code>run2 &lt;- run_camodel(kubo_model, init, times = seq(0, 128, by = 8))</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.498 forest:0.502 
## iter =  10 (  8 %) empty:0.291 forest:0.709 [256.41 iter/s]
## iter =  20 ( 16 %) empty:0.227 forest:0.773 [256.41 iter/s]
## iter =  30 ( 23 %) empty:0.228 forest:0.772 [256.41 iter/s]
## iter =  40 ( 31 %) empty:0.231 forest:0.769 [256.41 iter/s]
## iter =  50 ( 39 %) empty:0.219 forest:0.781 [263.16 iter/s]
## iter =  60 ( 47 %) empty:0.233 forest:0.767 [263.16 iter/s]
## iter =  70 ( 54 %) empty:0.228 forest:0.772 [256.41 iter/s]
## iter =  80 ( 62 %) empty:0.235 forest:0.765 [263.16 iter/s]
## iter =  90 ( 70 %) empty:0.228 forest:0.772 [270.27 iter/s]
## iter = 100 ( 78 %) empty:0.231 forest:0.769 [256.41 iter/s]
## iter = 110 ( 85 %) empty:0.228 forest:0.772 [263.16 iter/s]
## iter = 120 ( 93 %) empty:0.232 forest:0.768 [263.16 iter/s]</code></pre>
<pre class="r"><code>covers2 &lt;- run2[[&quot;output&quot;]][[&quot;covers&quot;]]
tail(covers2)</code></pre>
<pre><code>##         t     empty    forest
## [12,]  88 0.2196045 0.7803955
## [13,]  96 0.2233887 0.7766113
## [14,] 104 0.2301636 0.7698364
## [15,] 112 0.2292480 0.7707520
## [16,] 120 0.2316284 0.7683716
## [17,] 128 0.2260742 0.7739258</code></pre>
<pre class="r"><code>plot(covers[ ,&quot;t&quot;], covers[ ,&quot;forest&quot;], type = &quot;l&quot;, col = &quot;red&quot;)
lines(covers2[ ,&quot;t&quot;], covers2[ ,&quot;forest&quot;], col = &quot;blue&quot;)</code></pre>
<p><img src="guide_files/figure-html/unnamed-chunk-14-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>Another option is to set the control argument
<code>save_covers_every</code> to something higher than one. This will
only save simulation output one out of several iterations:</p>
<pre class="r"><code>ctrl &lt;- list(save_covers_every = 8)
run3 &lt;- run_camodel(kubo_model, init, times = seq(0, 128, by = 1), 
                    control = ctrl)</code></pre>
<pre><code>## iter =   0 (  0 %) empty:0.498 forest:0.502 
## iter =  10 (  8 %) empty:0.298 forest:0.702 [256.41 iter/s]
## iter =  20 ( 16 %) empty:0.243 forest:0.757 [256.41 iter/s]
## iter =  30 ( 23 %) empty:0.239 forest:0.761 [270.27 iter/s]
## iter =  40 ( 31 %) empty:0.22 forest:0.78 [263.16 iter/s]
## iter =  50 ( 39 %) empty:0.22 forest:0.78 [270.27 iter/s]
## iter =  60 ( 47 %) empty:0.225 forest:0.775 [277.78 iter/s]
## iter =  70 ( 54 %) empty:0.231 forest:0.769 [270.27 iter/s]
## iter =  80 ( 62 %) empty:0.23 forest:0.77 [270.27 iter/s]
## iter =  90 ( 70 %) empty:0.217 forest:0.783 [270.27 iter/s]
## iter = 100 ( 78 %) empty:0.229 forest:0.771 [270.27 iter/s]
## iter = 110 ( 85 %) empty:0.236 forest:0.764 [270.27 iter/s]
## iter = 120 ( 93 %) empty:0.218 forest:0.782 [277.78 iter/s]</code></pre>
<pre class="r"><code>covers3 &lt;- run3[[&quot;output&quot;]][[&quot;covers&quot;]]
tail(covers3)</code></pre>
<pre><code>##         t     empty    forest
## [12,]  88 0.2255859 0.7744141
## [13,]  96 0.2269897 0.7730103
## [14,] 104 0.2363892 0.7636108
## [15,] 112 0.2307739 0.7692261
## [16,] 120 0.2180786 0.7819214
## [17,] 128 0.2214355 0.7785645</code></pre>
<pre class="r"><code>plot(covers[ ,&quot;t&quot;], covers[ ,&quot;forest&quot;], type = &quot;l&quot;, col = &quot;red&quot;, 
     xlab = &quot;t&quot;, ylab = &quot;forest cover&quot;)
lines(covers2[ ,&quot;t&quot;], covers2[ ,&quot;forest&quot;], col = &quot;blue&quot;)
lines(covers3[ ,&quot;t&quot;], covers3[ ,&quot;forest&quot;], col = &quot;darkgreen&quot;)
legend(x = &quot;right&quot;, 
       legend = c(&quot;original&quot;, &quot;reduced &#39;times&#39; vector&quot;, &quot;using &#39;save_covers_every&#39;&quot;), 
       col = c(&quot;black&quot;, &quot;blue&quot;, &quot;darkgreen&quot;), 
       lty = c(1, 1, 1))</code></pre>
<p><img src="guide_files/figure-html/unnamed-chunk-15-1.png" width="672" style="display: block; margin: auto;" /></p>
<p>A similar argument exists for saving landscapes,
<code>save_snapshots_every</code>, to reduce or increase the number of
landscapes being saved during the simulation, with similar effects.</p>
</div>
<div id="running-computations-on-the-fly" class="section level1">
<h1>Running computations on the fly</h1>
<div id="computing-things" class="section level2">
<h2>Computing things</h2>
<p>One of the easiest way to dissect the results of your simulation is
simply to store the landscape, or the covers of each state, then run
your computation after the fact. This is not always possible, however,
as the landscapes may be large, or your model may be running for a large
number of iterations. To avoid this, chouca can take a special function
that will be run at regular intervals as the simulation is running.</p>
<p>This function must have a specific form: its first argument should be
<code>t</code>, the current time of the simulation, and the second
should be <code>mat</code>, the current landscape.</p>
<p>For example, we can compute how the spatial autocorrelation changes
in the landscape as the simulation is running, measured by the Moran’s I
index (available in package (spatialwarnings)[<a
href="https://cran.r-project.org/package=spatialwarnings"
class="uri">https://cran.r-project.org/package=spatialwarnings</a>]):</p>
<pre class="r"><code>mod &lt;- ca_library(&quot;forestgap&quot;)
init &lt;- generate_initmat(mod, c(TREE = .5, EMPTY = .5), nr = 256)

control_args &lt;- list(save_covers_every = 0, 
                     custom_output_every = 1, 
                     custom_output_fun = function(t, mat) { 
                       m &lt;- matrix(mat == &quot;TREE&quot;, nrow = nrow(mat), ncol = ncol(mat))
                       data.frame(t = t, ac = spatialwarnings::raw_moran(mat))
                     })

out &lt;- run_camodel(mod, init, times = seq(0, 64), control = control_args)</code></pre>
<pre><code>## iter =  0 (  0 %) EMPTY:0.501 TREE:0.499 
## iter = 10 ( 15 %) EMPTY:0.707 TREE:0.293 [65.79 iter/s]
## iter = 20 ( 31 %) EMPTY:0.707 TREE:0.293 [72.46 iter/s]
## iter = 30 ( 46 %) EMPTY:0.707 TREE:0.293 [66.67 iter/s]
## iter = 40 ( 62 %) EMPTY:0.707 TREE:0.293 [66.67 iter/s]
## iter = 50 ( 77 %) EMPTY:0.707 TREE:0.293 [66.23 iter/s]
## iter = 60 ( 92 %) EMPTY:0.707 TREE:0.293 [65.79 iter/s]</code></pre>
<p>The results can be extracted the following way:</p>
<pre class="r"><code>my_output &lt;- out[[&quot;output&quot;]][[&quot;custom&quot;]]</code></pre>
<p>By default, all custom outputs are stored in a list, so a common
operation is to transform it into a table using <code>rbind</code> or
any other function:</p>
<pre class="r"><code>my_tbl &lt;- do.call(rbind, my_output)
tail(my_tbl, 10)</code></pre>
<pre><code>##     t       ac
## 56 55 0.114236
## 57 56 0.114345
## 58 57 0.114236
## 59 58 0.114345
## 60 59 0.114236
## 61 60 0.114345
## 62 61 0.114236
## 63 62 0.114345
## 64 63 0.114236
## 65 64 0.114345</code></pre>
</div>
<div id="visualising-simulations" class="section level2">
<h2>Visualising simulations</h2>
<p>The use of custom functions has the nice side-effect that simulations
can be visualised as they are running. This can be done, again by
passing a specific function to <code>chouca</code>. The package includes
a few helpers to do so.</p>
<p>The first one is <code>landscape_plotter()</code>, which can be used
as follow, and will display the landscape as it is being run. We use the
“rock-paper-scissor” model included with chouca as example for its nice
results:</p>
<pre class="r"><code>mod &lt;- ca_library(&quot;rock-paper-scissor&quot;)

ctrl &lt;- list(custom_output_every = 1, 
             precompute_probas = FALSE, 
             custom_output_fun = landscape_plotter(mod))

init &lt;- generate_initmat(mod, rep(1, 3)/3, 100, 178)

out &lt;- run_camodel(mod, init, seq(0, 128), control = ctrl)</code></pre>
<video width="384" controls loop>
<source src="guide_files/figure-html/giflandscape.webm" />
</video>
<p>Another option to visualise simulations as they are run is using
<code>trace_plotter()</code>, which will display the covers of each
state in the landscape during the run:</p>
<pre class="r"><code>ctrl &lt;- list(custom_output_every = 1, 
             custom_output_fun = trace_plotter(mod, init, max_samples = 128), 
             console_output_every = 128)

out &lt;- run_camodel(mod, init, seq(0, 512), control = ctrl)</code></pre>
<video width="384" controls loop>
<source src="guide_files/figure-html/giftraces.webm" />
</video>
<p>These two functions have many options to customize their output to
your liking, which are documented in <code>?trace_plotter</code> or
<code>?landscape_plotter</code>. Of course using them involves a large
performance penalty as plots needs to be redrawn during the execution of
the simulation.</p>
</div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Kubo, Takuya, Yoh Iwasa, and Naoki Furumoto. 1996. “Forest Spatial
Dynamics with Gap Expansion: Total Gap Area and Gap Size Distribution.”
Journal of Theoretical Biology 180 (3): 229–46.</p>
<p>Mayor, Ángeles G., Sonia Kéfi, Susana Bautista, Francisco Rodríguez,
Fabrizio Cartení, and Max Rietkerk. 2013. “Feedbacks between Vegetation
Pattern and Resource Loss Dramatically Decrease Ecosystem Resilience and
Restoration Potential in a Simple Dryland Model.” Landscape Ecology 28
(5): 931–42. <a href="https://doi.org/10.1007/s10980-013-9870-4"
class="uri">https://doi.org/10.1007/s10980-013-9870-4</a>.</p>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeCodeFolding("show" === "show");
});
</script>

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
