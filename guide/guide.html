<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Alexandre Génin a.a.h.genin@uu.nl" />


<title>The complete guide to chouca</title>

<script src="guide_files/header-attrs-2.14/header-attrs.js"></script>
<script src="guide_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="guide_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="guide_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="guide_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="guide_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="guide_files/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="guide_files/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="guide_files/tocify-1.9.1/jquery.tocify.js"></script>
<script src="guide_files/navigation-1.1/tabsets.js"></script>
<link href="guide_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="guide_files/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div id="header">



<h1 class="title toc-ignore">The complete guide to
<code>chouca</code></h1>
<h4 class="author">Alexandre Génin <a href="mailto:a.a.h.genin@uu.nl"
class="email">a.a.h.genin@uu.nl</a></h4>

</div>


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<p><code>chouca</code> is engine in R for <a
href="https://en.wikipedia.org/wiki/Stochastic_cellular_automaton">stochastic
cellular automata</a>: a class of models that describes the temporal
dynamics of a 2D landscape made of cells. Each cell can be in one of a
finite number of states. In such model, the time is discrete, and at
each iteration cells have a probability of switching from one state to
another that typically depends on model parameters, and the state of
their neighbors.</p>
<p>A picture being worth a thousand words, the output of a stochastic
cellular automaton looks like the following animation in practice:</p>
<video width="288" controls loop>
<source src="guide_files/figure-html/gifcreate.webm" />
</video>
<p>Stochastic cellular automata are widely used to describe the dynamics
of landscapes, for example in ecology, to describe the dynamics of
forests or coral reefs over space. Yet, implementations are often
ad-hoc, carried out by the authors themselves, which is prone to bugs
and often leads to quite slow implementations. <code>chouca</code> tries
to avoid this by providing a base onto which such models can be built.
The goal is for the user to declare the probabilities of state
transition of the model, then <code>chouca</code> handles the rest.</p>
<p>While <code>chouca</code> is built mainly for stochastic cellular
automata, it can also handle non-stochastic cellular automata, such as
the game of life or the <a
href="https://www.youtube.com/watch?v=TvZI6Xc0J1Y">rock-paper-scissor
automaton</a>. We aim to support a large selection of cellular automata,
while preserving decent performance. This is done through by writing
most of the code in C++, and being able to produce and compile C++ code
on the fly for a specific model at run time. This enables many compiler
optimizations that would be impossible with pre-compiled code, and often
improves simulation speed 10-100x.</p>
<div id="a-small-example" class="section level2">
<h2>A small example</h2>
<p>Let’s define a small forest model. In such model, cells can be either
‘empty’, or filled with a tree, what we call here the ‘forest’ state.
Trees produce seeds that fly over the whole landscape and land
haphazardly in any cell. Thus, the probability of an empty cell to
switch to the forested state is proportional to <span
class="math inline">\(p_+\)</span>, the proportion of cells with trees
in the landscape. If we represent the empty state as <span
class="math inline">\(0\)</span> and the forest state as <span
class="math inline">\(+\)</span>, this probability of transition is
thus:</p>
<p><span class="math display">\[P(0 \rightarrow +) = \alpha
p_+\]</span></p>
<p>where <span class="math inline">\(\alpha\)</span> is the rate at
which seeds are produced by each tree.</p>
<p>Trees naturally die over time, and because wind bursts are stronger
in empty areas, trees have a higher of dying when they have empty
neighboring cells:</p>
<p><span class="math display">\[P(+ \rightarrow 0) = \delta_0 + \delta
q_{0}\]</span></p>
<p>Here, <span class="math inline">\(q_0\)</span> denotes the proportion
of cells around the focal cell that are empty, i.e. in the <span
class="math inline">\(0\)</span> state.</p>
<p>This model has three parameters, <span
class="math inline">\(\alpha\)</span>, <span
class="math inline">\(\delta_0\)</span> and <span
class="math inline">\(\delta\)</span>. Such a model can be defined in
<code>chouca</code> using the following syntax:</p>
<pre class="r"><code>model &lt;- camodel(transition(from = &quot;0&quot;, to = &quot;+&quot;, ~ alpha * p[&quot;+&quot;]), 
                 transition(from = &quot;+&quot;, to = &quot;0&quot;, ~ delta0 + delta * q[&quot;0&quot;]), 
                 parms = list(alpha = 0.6, delta0 = 0.05, delta = 0.4), 
                 wrap = TRUE, 
                 neighbors = 8)</code></pre>
<p>We first declare the two transitions, by the states between which it
occurs, and how to compute the probability. In that expression,
<code>p</code> refers to the proportions of cells in each state, and
<code>q</code> refers to the the proportion of neighbors in each state.
We then set the argument <code>parms</code> to a list containing the
numerical values of the model parameters. We use the argument
<code>wrap = TRUE</code> to state that the model will be run on a space
in which the edges “wrap around”, and the first column/top row of the
landscape is neighboring the rightmost/bottom column. We use the
argument <code>neighbors = 8</code> to state that we want to consider
all 8 neighbors of a cell, i.e. including those that are diagonal. This
type of neighborhood is referred to as <a
href="https://en.wikipedia.org/wiki/Moore_neighborhood">Moore</a>
neighborhood.</p>
<p>A summary of the model can be printed on the R command line, that
recalls the model parameters, along with the</p>
<pre class="r"><code>model</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: 0 + 
##  
## Transition: 0 -&gt; + 
##   ~   alpha * p[&quot;+&quot;] 
## Transition: + -&gt; 0 
##   ~   delta0 + delta * q[&quot;0&quot;] 
##  
## Neighborhood: 8x8 
## Wrap: TRUE 
## Max error: 2.734479e-13 (OK) 
## Max rel error: 5.195466e-13 (OK)</code></pre>
<p>The next step is to define the initial landscape from which we want
to start the simulation. We can do so using the function
<code>generate_initmat</code>:</p>
<pre class="r"><code>init_mat &lt;- generate_initmat(model, pvec = c(`0` = 0.5, `+` = 0.5), nr = 128, nc = 256)</code></pre>
<p>Here we initalize the covers to half tree and half empty space using
the argument <code>pvec</code>, and use a landscape of 128 rows by 256
columns. We can now run the simulation:</p>
<pre class="r"><code>out &lt;- run_camodel(model, init_mat, niter = 100)</code></pre>
<pre><code>## t =  0 (  0 %) 0:0.499 +:0.501 
## t = 10 ( 10 %) 0:0.29 +:0.71 [32.57 iter/s]
## t = 20 ( 20 %) 0:0.241 +:0.759 [33.90 iter/s]
## t = 30 ( 30 %) 0:0.227 +:0.773 [34.25 iter/s]
## t = 40 ( 40 %) 0:0.225 +:0.775 [33.22 iter/s]
## t = 50 ( 50 %) 0:0.222 +:0.778 [32.68 iter/s]
## t = 60 ( 60 %) 0:0.221 +:0.779 [33.90 iter/s]
## t = 70 ( 70 %) 0:0.231 +:0.769 [34.84 iter/s]
## t = 80 ( 80 %) 0:0.225 +:0.775 [35.09 iter/s]
## t = 90 ( 90 %) 0:0.226 +:0.774 [35.34 iter/s]
## t = 100 (100 %) 0:0.223 +:0.777 [34.36 iter/s]</code></pre>
<p>And display the results, either in the R console, or as a plot:</p>
<pre class="r"><code>summary(out)</code></pre>
<pre><code>## Stochastic Cellular Automaton simulation
## 
## Iterations: 100
## Landscape size: 128x256
## Global covers:
##          t         0         +
##  [96,]  95 0.2288818 0.7711182
##  [97,]  96 0.2277222 0.7722778
##  [98,]  97 0.2244568 0.7755432
##  [99,]  98 0.2254028 0.7745972
## [100,]  99 0.2263184 0.7736816
## [101,] 100 0.2230225 0.7769775
## Landscapes saved: 51
## 
## The following methods are available: 
## image plot</code></pre>
<pre class="r"><code>par(mfrow = c(1, 2))
plot(out)
title(&quot;Global covers over time&quot;)
image(out)</code></pre>
<p><img src="guide_files/figure-html/display_plot-1.png" width="1152" style="display: block; margin: auto;" /></p>
</div>
</div>
<div id="supported-models" class="section level1">
<h1>Supported models</h1>
<p><code>chouca</code> works only with models that use either a 4x4 or
8x8 neighborhood (von Neumann or Moore neighborhood, respectively), and
in which the effects are isotropic, i.e. all neighbors have a similar
effect regardless of whether they are above, or below a given cell.</p>
<p>The probabilities of transition can have any form, but respecting
those two principles will work better for <code>chouca</code>:</p>
<ul>
<li><p>To be 100% accurate, transition probabilities must be a linear
combination of the products of the local or global proportion of cells
in a given state. For example, a transition probability defined as <span
class="math inline">\(P(0 \rightarrow +) = 0.1 + p_+ + p_0 q_0\)</span>
works perfectly, but something involving non-linear functions such as
<span class="math inline">\(P(0 \rightarrow +) = 0.1 + e^{-
p_+}\)</span> will not be ideal (see below for the
consequences).</p></li>
<li><p>The transition probabilities can be any function of the
proportion of neighbors in a given state. Rules such as “if one neighbor
is in state <span class="math inline">\(0\)</span>, then the probability
of transition is modified” are OK. Such rules involving multiple types
of neighbors are not, e.g. “if one neighbor is in state <span
class="math inline">\(0\)</span> <em>and</em> another one in state <span
class="math inline">\(+\)</span>, then…”.</p></li>
</ul>
<p>Overall, the functional form of transitions probabilities must be the
following:</p>
<p><span class="math display">\[
P( a \rightarrow b ) = \beta_0 +
  \sum_{s \in S} f_s(q_s) +
  \sum_{s \in S, t \in S} \beta_{qq,s,t} q_s^{ \alpha_{qq, s} } q_t^{
\alpha_{qq, t} } +
  \sum_{s \in S, t \in S} \beta_{pq,s,t} p_s^{ \alpha_{pq, s} } q_t^{
\alpha_{pq, t} } +
  \sum_{s \in S, t \in S} \beta_{pp,s,t} p_s^{ \alpha_{pp, s} } p_t^{
\alpha_{pp, t} }
\]</span></p>
<p>where <span class="math inline">\(S\)</span> represents the set of
states of the cellular automaton, <span
class="math inline">\(f_s\)</span> can be any function, the <span
class="math inline">\(\beta_{x,y,z}\)</span>s are constants, and the
<span class="math inline">\(\alpha_{x,y}\)</span> are integer
constants.</p>
<p>When writing a transition probability, <code>chouca</code> will try
to approximate it with the above function, check that how accurately
this has been done, and report any deviation. For example, the following
model has transition probabilities that cannot be represented with 100%
accuracy, because of the exponential term, and a warning is
produced:</p>
<pre class="r"><code>camodel(transition(from = &quot;0&quot;, to = &quot;+&quot;, ~ 1 + exp( 1 + - p[&quot;+&quot;] * q[&quot;+&quot;])), 
        wrap = TRUE, 
        neighbors = 4)</code></pre>
<pre><code>## Warning in FUN(X[[i]], ...): Residual error in computed probabilities
##   max error: 0.000188
##   max rel error: 7.34e-05
## Problematic probability expression: 
## Transition from 0 to +
##   ~ 1 + exp(1 + -p[&quot;+&quot;] * q[&quot;+&quot;])</code></pre>
<p><code>chouca</code> reports both the absolute and relative difference
between the approximated and true model probability. Many models have no
error and no approximation is made, but you can go on with a model with
error if you know what you are doing. Here, the relative error is
3.852457e-05 in the worst case, so the results would probably be
extremely close to a model without approximation.</p>
<p>To control a bit better this error, we can convert the above model to
a form that is more palatable to <code>chouca</code>, by using the first
few terms of the (Maclaurin)[<a
href="https://en.wikipedia.org/wiki/Taylor_series#Exponential_function"
class="uri">https://en.wikipedia.org/wiki/Taylor_series#Exponential_function</a>]
series for the exponential function: <span class="math inline">\(e^x = 1
+ x + \frac{x^2}{2!} + \frac{x^3}{3!}\)</span>.</p>
<pre class="r"><code>exp_approx &lt;- function(x) 1 + x + x^2/(2*1) + x^3/(3*2*1)
camodel(transition(from = &quot;0&quot;, to = &quot;+&quot;, ~ 1 + exp_approx(- p[&quot;+&quot;] * q[&quot;+&quot;])), 
        wrap = TRUE, 
        neighbors = 4)</code></pre>
<pre><code>## Stochastic Cellular Automaton 
##  
## States: 0 + 
##  
## Transition: 0 -&gt; + 
##   ~   1 + exp_approx(-p[&quot;+&quot;] * q[&quot;+&quot;]) 
##  
## Neighborhood: 4x4 
## Wrap: TRUE 
## Max error: 9.031531e-11 (OK) 
## Max rel error: 5.718224e-11 (OK)</code></pre>
<p>This time, no error is reported by chouca, as this new model follows
the exact functional form required.</p>
</div>
<div id="chouca-goals" class="section level1">
<h1><code>chouca</code> goals:</h1>
<ul>
<li><p><code>chouca</code> is fast, although some things could be
faster. It depends on your model complexity.</p></li>
<li><p><code>chouca</code> wants to be fast, and help you explore your
model behavior.</p></li>
</ul>
<div id="supported-types-of-models" class="section level2">
<h2>Supported types of models</h2>
<p><code>chouca</code> does not support all kinds of cellular automata.
Probabilities must follow the following form. Calling x, y z,</p>
<p>If a model does not follow this, the probabilities of transition will
be approximate. The good news is that <code>chouca</code> is able to
tell you the error, both relative and absolute: it is up to you to
decide whether this is a sufficiently good approximation.</p>
</div>
</div>
<div id="visualising-simulations" class="section level1">
<h1>Visualising simulations</h1>
<p><code>chouca</code> can display the covers of each state, or the
complete landscape as the simulation is running.</p>
</div>
<div id="performance" class="section level1">
<h1>Performance</h1>
<p>Parallel processing</p>
</div>
<div id="examples" class="section level1">
<h1>Examples</h1>
<div id="a-first-example" class="section level2">
<h2>A first example</h2>
</div>
<div id="a-more-complex-example" class="section level2">
<h2>A more complex example</h2>
</div>
<div id="a-model-with-errors" class="section level2">
<h2>A model with errors</h2>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
